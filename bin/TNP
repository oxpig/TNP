#!/data/localhost/gordon/miniconda3/envs/nanob/bin/python

####################################################################################################
####                          The Therapeutic Nanobody Profiler (TNP)                           ####
####################################################################################################

#AUTHORS: Gemma Gordon (1), Charlotte M Deane (1)
#
#(1) Department of Statistics (Oxford Protein Informatics Group), University of Oxford, UK

####################################################################################################
# REQUIRED MODULES
from theraprofnano.CDR_Profiler.CDR_Assigner import main as region_and_aa_dicts
from theraprofnano.CDR_Profiler.CDR3_Conf_Assigner import main_compactness as compactness_calc
from theraprofnano.Hydrophobicity_and_Charge_Profiler.Hydrophobicity_and_Charge_Assigner import CreateAnnotation as hydrophob_and_charge_calc
from theraprofnano.Plotters.CDRLen_D3_Template import cdr_graph # called in function for web-app
from theraprofnano.Plotters.CDR3Len_D3_Template import cdr3_len_graph
from theraprofnano.Plotters.CDR3Conf_D3_Template import cdr3_conf_graph
from theraprofnano.Plotters.PSH_D3_Template import psh_graph
from theraprofnano.Plotters.PPC_D3_Template import ppc_graph
from theraprofnano.Plotters.PNC_D3_Template import pnc_graph
import numpy as np
#from ABDB.AbPDB import AntibodyParser
from Bio import SeqIO
import pickle as pickle
import subprocess,time,re,argparse,json,os,sys,shutil
import multiprocessing as mp
import os,glob
import anarci
from anarci import anarci, run_anarci

####################################################################################################

columns = 100
linedivide = "\n\n" + ("-"*columns) + "\n\n"

header = linedivide + """

---------------------------------------------------------------------------------------------------------\n
---------------------------------------------------------------------------------------------------------\n
                \/                       _____ _   _ ____                   \/
                ⊂'l                      |_   _| \ | |  _ \                 ⊂'l     
                ll                        | | |  \| | |_) |                 ll     
                llama~                    | | | |\  |  __/                  llama~ 
                || ||                     |_| |_| \_|_|                     || || 
                '' ''                                                       '' ''
---------------------------------------------------------------------------------------------------------\n
---------------------------------------------------------------------------------------------------------\n

\nTHE THERAPEUTIC NANOBODY PROFILER\n

Gemma Gordon, 2025\n

Software developed in the Oxford Protein Informatics Group, Department of Statistics, University of Oxford\n

Example usage:\n

TNP -s QVKLQESGAELARPGASVKLSCKASGYTFTNYWMQWVKQRPGQGLDWIGAIYPGDGNTRYTHKFKGKATLTADKSSSTAYMQLSSLASEDSGVYYCARGEGNYAWFAYWGQGTTVTVSS --output TNP_example_output
""" + linedivide


####################################################################################################
# UPDATE FLAG VALUES HERE    
# Function to assign a flag colour based on the value of a TNP metric
def assign_flag(metric, value):
    
    # Total CDR Length (L)
    if metric == "L":
        if   value <  20 or  value >  39:
            return "red"
        elif value >= 20 and value <= 24:
            return "amber"
        elif value >= 37 and value <= 39:
            return "amber"
        else:
            return "green"
        
    # CDR3 Length (L3)
    elif metric == "L3":
        if   value <  5 or  value >  23:
            return "red"
        elif value >= 5 and value <= 8:
            return "amber"
        elif value >= 21 and value <= 23:
            return "amber"
        else:
            return "green"
    
    # Total CDR3 compactness (C)
    elif metric == "C":
        if   value <  0.56 or  value >  1.61:
            return "red"
        elif value >= 0.56 and value <= 0.81:
            return "amber"
        elif value >= 1.57 and value <= 1.61:
            return "amber"
        else:
            return "green"
            
    # Patches of surface hydrophobicity (PSH)
    elif metric == "PSH":
        if   value <  73.40 or  value >  155.47:
            return "red"
        elif value >= 73.40 and value <= 79.59:
            return "amber"
        elif value >= 126.83 and value <= 155.47:
            return "amber"
        else:
            return "green"

    # Patches of positive charge (PPC)
    elif metric == "PPC":
        if   value > 1.18:
            return "red"
        elif value >= 0.39 and value <= 1.18:
            return "amber"
        else:
            return "green"
            
    # Patches of negative charge (PNC)
    elif metric == "PNC":
        if   value > 1.88:
            return "red"
        elif value >= 1.47 and value <= 1.88:
            return "amber"
        else:
            return "green"
            
            
####################################################################################################
# Stuff to remove hydrogens from NanoBodyBuilder2 output models 
# NOTE - from TAP - [23 Jan 2023, Broncio]: ImmuneBuilder add hydrogens by default for openmm relaxation
import re
from Bio.PDB import PDBParser, PDBIO, Select

_hydrogen = re.compile("[123 ]*H.*")

class RemoveHydrogen(Select):
    def accept_atom(self, atom):
        """Verify if atoms are not Hydrogen."""
        # atoms - get rid of hydrogens
        name = atom.get_id()
        return 0 if _hydrogen.match(name) else 1

def pdb_remove_hydrogens(input_pdb):
    try:
        pdb = PDBParser().get_structure("antibody", input_pdb)
        io = PDBIO()
        io.set_structure(pdb)

        output_model = f'{input_pdb[:-4]}.pdb'
        io.save(output_model, RemoveHydrogen())

    except Exception as e:
        print(e)

####################################################################################################

def get_tetrad_residues(sequence):
    """
    Returns tetrad motif/hallmark residues on the nanobody FR2 region - sequence input mode only
    
    """

    # Get tetrad positions and residue from numbering sequence
    tetrad_residues = []
    tetrad_positions = [42,49,50,52] # IMGT positions
    numbering =  run_anarci(sequence, scheme='IMGT', allowed_species=None)[1][0][0][0]
    for n in numbering:
        if n[0][0] in tetrad_positions:
            tetrad_residues.append((n[0][0],n[1]))
    
    tetrad_motif = ''.join(t[1] for t in tetrad_residues)

    return tetrad_motif


####################################################################################################


# Main function that runs TNP on a sequence
def main(heavy_name, heavy_sequence, h_scale, output, web, verbose=False):

    print(header)

    if True:
        CDR_data_loc = os.path.join(output, "Outputs")
        Model_data_loc = os.path.join(output, "Final_Models")
        status = "Good"
        abbrev_name = heavy_name[:-2]
        print("TNP is running on sequence %s" %(abbrev_name))

        logfile = os.path.join(output, abbrev_name+"_TNP.log")
        with open(logfile,"w") as fo:
        
            fo.write("The TNP job initialised successfully for "+abbrev_name+".\nIt will calculate total CDR length, CDR3 length, CDR3 compactness, and patches of surface hydrophobicity and charge.\n\n--------------------------------------------------------------\n\n")

            if verbose: print("\nAnalysing CDR loops...\n\n")

            try:
                heavy_cdr_dict, heavy_len_dict = region_and_aa_dicts(heavy_name,heavy_sequence,"H",output,verbose=verbose)
                fo.write("TNP managed to number the sequence with ANARCI\n")
            except:
                print("TNP could not number the sequence %s with ANARCI" %abbrev_name)
                fo.write("TNP failed to number the sequence with ANARCI\n")
                return

            total_imgt_cdr_length = 0
            heavy_loops = ['cdrh1','cdrh2','cdrh3']

            # Calculate total CDR loops length
            for loop in heavy_loops:
                total_imgt_cdr_length += heavy_len_dict['imgt'][loop]
            
            # Calculate CDR3 loop length
            imgt_cdr3_length = heavy_len_dict['imgt']['cdrh3']

            if verbose: 
                print(linedivide + "Calling NanoBodyBuilder2 (ImmuneBuilder model for nanobodies) to model your nanobody\n\n") # NEW

            try:
                os.mkdir(abbrev_name)

                cmd = ["NanoBodyBuilder2",
                       "--heavy_sequence", heavy_sequence,
                       "--output", os.path.join(abbrev_name, abbrev_name + ".pdb"),
                       "--n_threads", "1"]
                if verbose:
                    cmd.append("--verbose")
                    
                subprocess.run(cmd, check=True)

                fo.write("NanoBodyBuilder2 (ImmuneBuilder) was able to generate a model for this sequence\n")

                try:
                    input_pdb = os.path.join(abbrev_name, abbrev_name)+".pdb"
                    pdb_remove_hydrogens(input_pdb)
                    print("Removed all Hydrogens from NanoBodyBuilder2 model")
                    
                except Exception as e:
                        print(e)

            except Exception as e: 
                print("ERROR: NanoBodyBuilder2 (ImmuneBuilder) failed to generate a model for your nanobody")
                fo.write("NanoBodyBuilder2 (ImmuneBuilder) was unable to generate a model for your nanobody\n")
                print(e)
                return

            try:
                # Generate modelling_details.jsonp file (Now a separate step from ImmuneBuilder)
                # import sys
                # sys.path.append("../scripts/")
                from scripts.process_pdb import get_modelling_details
                modelling_details = get_modelling_details(os.path.join(abbrev_name, abbrev_name)+".pdb", type='nanobody', save=True)
                fo.write("Saved modelling_details.jsonp for NanoBodyBuilder2 (ImmuneBuilder) model\n")

            except Exception as e:
                print("ERROR: Failed to process output PDB. " + str(e))

            if os.path.exists(os.path.join("Raw_Model_Outputs", abbrev_name)):
                shutil.rmtree(os.path.join("Raw_Model_Outputs", abbrev_name))
            subprocess.call(["mv",abbrev_name,"Raw_Model_Outputs/"+str(heavy_name[:-2])])
            subprocess.call(["cp","Raw_Model_Outputs/"+str(heavy_name[:-2])+"/"+abbrev_name+".pdb","Final_Models/"+str(heavy_name[:-2])+"_NanoBodyBuilder2_Model.pdb"])
            subprocess.call(["cp","Raw_Model_Outputs/"+str(heavy_name[:-2])+"/modelling_details.jsonp","Final_Models/"+str(heavy_name[:-2])+"_NanoBodyBuilder2_Model_Details.json"])
            subprocess.call(["cp","Raw_Model_Outputs/"+str(heavy_name[:-2])+"/sequence_liabilities.csv","Final_Models/"+str(heavy_name[:-2])+"_NanoBodyBuilder2_Sequence_Liabilities.json"])

            if verbose: 
                print(linedivide + "NanoBodyBuilder2 (ImmuneBuilder) successfully modelled your nanobody.\n\n")

            if verbose: 
                print(linedivide + "Calculating CDR3 compactness (a descriptor of conformation) for your nanobody.\n\n")

            cdr3_compactness_rho = compactness_calc(os.path.join(Model_data_loc, abbrev_name+"_NanoBodyBuilder2_Model.pdb"), "imgt", verbose=verbose)
            # in case calculation failed, e.g. anchor residues missing in structure
            if cdr3_compactness_rho != None:
                cdr3_compactness = imgt_cdr3_length / cdr3_compactness_rho # UPDATED (corrected) 23.08.25
                fo.write("TNP was able to calculate a CDR3 compactness score for your model structure.\n")
                if verbose: 
                    print(linedivide + "TNP was able to calculate a CDR3 compactness score for your model structure.\n\n")
            else:
                cdr3_compactness = np.nan()
                fo.write("TNP was not able to calculate a CDR3 compactness score for your model structure.\n")
                if verbose: 
                    print(linedivide + "TNP was not able to calculate a CDR3 compactness score for your model structure.\n\n")


            if verbose:
                print(linedivide + "Getting nanobody hallmark residues (nanobody tetrad) from your sequence...\n\n")
            
            try:
                tetrad_motif = get_tetrad_residues(heavy_sequence)
                fo.write("Nanobody tetrad motif is: " + tetrad_motif +" (IMGT positions 42, 49, 50, 52)\n")
            except:
                tetrad_motif = None
                fo.write("Could not get nanobody hallmark residues (nanobody tetrad) from your sequence.\n")
                if verbose:
                    print(linedivide + "Could not get nanobody hallmark residues (nanobody tetrad) from your sequence...\n\n")
    

            if verbose:
                print(linedivide + "Finally, calculating surface hydrophobicity and charge properties for your nanobody at pH 7.4 (with salt-bridge correction)...\n\n")

            hydrophob_and_charge_dict = hydrophob_and_charge_calc(h_scale, 7.4, os.path.join(Model_data_loc, abbrev_name+"_NanoBodyBuilder2_Model.pdb"), "IG", "imgt", verbose=verbose)

            fo.write("TNP was able to calculate PSH, PPC and PNC scores for your model structure.\n")


            ###############################################################################################################

            nb_tnp_dictionary = {}
            nb_tnp_dictionary['name'] = abbrev_name
            nb_tnp_dictionary['Total CDR Length'] = total_imgt_cdr_length
            nb_tnp_dictionary['CDR3 Length'] = imgt_cdr3_length
            nb_tnp_dictionary['CDR3 Compactness'] = cdr3_compactness
            nb_tnp_dictionary['PSH'] = hydrophob_and_charge_dict[h_scale]['Patch_Hydrophob_CDR']
            nb_tnp_dictionary['PPC'] = hydrophob_and_charge_dict[h_scale]['Patch_Pos_Charge_CDR']
            nb_tnp_dictionary['PNC'] = hydrophob_and_charge_dict[h_scale]['Patch_Neg_Charge_CDR']
            
            nb_tnp_dictionary['Flags'] = { "L"     : assign_flag("L", total_imgt_cdr_length),
                                           "L3"    : assign_flag("L3", imgt_cdr3_length),
                                           "C"     : assign_flag("C", cdr3_compactness),
                                           "PSH"   : assign_flag("PSH", hydrophob_and_charge_dict[h_scale]['Patch_Hydrophob_CDR']),
                                           "PPC"   : assign_flag("PPC", hydrophob_and_charge_dict[h_scale]['Patch_Pos_Charge_CDR']),
                                           "PNC"   : assign_flag("PNC", hydrophob_and_charge_dict[h_scale]['Patch_Neg_Charge_CDR'])}
                                           
            fo.write("\n\nSummary Statistics for %s:\n" %(abbrev_name))
            fo.write("    Total IMGT CDR Length: %d (%s flag)\n" %(nb_tnp_dictionary['Total CDR Length'], nb_tnp_dictionary['Flags']['L'].upper()))
            fo.write("    IMGT CDR3 Length: %d (%s flag)\n" %(nb_tnp_dictionary['CDR3 Length'], nb_tnp_dictionary['Flags']['L3'].upper()))
            fo.write("    IMGT CDR3 compactness: %f (%s flag)\n" %(nb_tnp_dictionary['CDR3 Compactness'], nb_tnp_dictionary['Flags']['C'].upper()))
            fo.write("    Patch CDR Surface Hydrophobicity score is: %f (%s flag)\n" %(nb_tnp_dictionary['PSH'], nb_tnp_dictionary['Flags']['PSH'].upper()))
            fo.write("    Patch CDR Positive Charge score is: %f (%s flag)\n" %(nb_tnp_dictionary['PPC'], nb_tnp_dictionary['Flags']['PPC'].upper()))
            fo.write("    Patch CDR Negative Charge score is: %f (%s flag)\n" %(nb_tnp_dictionary['PNC'], nb_tnp_dictionary['Flags']['PNC'].upper()))

            # Populate the output graphs!
            # Only if being run for the web server
            if web:
                from theraprofnano.Plotters.CDRLen_D3_Template import cdr_graph
                from theraprofnano.Plotters.CDR3Len_D3_Template import cdr3_len_graph
                from theraprofnano.Plotters.CDR3Conf_D3_Template import cdr3_conf_graph
                from theraprofnano.Plotters.PSH_D3_Template import psh_graph
                from theraprofnano.Plotters.PPC_D3_Template import ppc_graph
                from theraprofnano.Plotters.PNC_D3_Template import pnc_graph

                flag2hex = { "red": "#FF0000", "amber": "#FFA500", "green": "#5CBE67" }

                #CDR LENGTH GRAPH
                cdr_graph['data']['data01'][0][5] = nb_tnp_dictionary['Total CDR Length']        # 5 for upper and lower bound, 3 for upper only
                cdr_graph['data']['data01'][1][5] = nb_tnp_dictionary['Total CDR Length']
                cdr_graph['axes'][0]['lines'][4]['color'] = flag2hex[nb_tnp_dictionary['Flags']['L']]

                with open(os.path.join(output, "CDRLen_D3_Template.json"),"w") as fo4:
                    json.dump(cdr_graph,fo4)

                #CDR3 LENGTH GRAPH
                cdr3_len_graph['data']['data01'][0][5] = nb_tnp_dictionary['CDR3 Length']        
                cdr3_len_graph['data']['data01'][1][5] = nb_tnp_dictionary['CDR3 Length']
                cdr3_len_graph['axes'][0]['lines'][4]['color'] = flag2hex[nb_tnp_dictionary['Flags']['L3']]

                with open(os.path.join(output, "CDR3Len_D3_Template.json"),"w") as fo4:
                    json.dump(cdr3_len_graph,fo4)
                
                #CDR3 COMPACTNESS GRAPH
                cdr3_conf_graph['data']['data01'][0][5] = nb_tnp_dictionary['CDR3 Compactness']       
                cdr3_conf_graph['data']['data01'][1][5] = nb_tnp_dictionary['CDR3 Compactness']
                cdr3_conf_graph['axes'][0]['lines'][4]['color'] = flag2hex[nb_tnp_dictionary['Flags']['C']]

                with open(os.path.join(output, "CDR3Conf_D3_Template.json"),"w") as fo4:
                    json.dump(cdr3_conf_graph,fo4)

                #PSH GRAPH
                psh_graph['data']['data01'][0][5] = nb_tnp_dictionary['PSH']#['Hydrophobicity and Charge'][0]['Patch_Hydrophob_CDR']
                psh_graph['data']['data01'][1][5] = nb_tnp_dictionary['PSH']#['Hydrophobicity and Charge'][0]['Patch_Hydrophob_CDR']
                psh_graph['axes'][0]['lines'][4]['color'] = flag2hex[nb_tnp_dictionary['Flags']['PSH']]       

                with open(os.path.join(output, "PSH_D3_Template.json"),"w") as fo4:
                    json.dump(psh_graph,fo4)

                #PPC GRAPH
                ppc_graph['data']['data01'][0][3] = nb_tnp_dictionary['PPC']#['Hydrophobicity and Charge'][0]['Patch_Pos_Charge_CDR']
                ppc_graph['data']['data01'][1][3] = nb_tnp_dictionary['PPC']#['Hydrophobicity and Charge'][0]['Patch_Pos_Charge_CDR']
                ppc_graph['axes'][0]['lines'][2]['color'] = flag2hex[nb_tnp_dictionary['Flags']['PPC']]

                with open(os.path.join(output, "PPC_D3_Template.json"),"w") as fo4:
                    json.dump(ppc_graph,fo4)

                #PNC GRAPH
                pnc_graph['data']['data01'][0][3] = nb_tnp_dictionary['PNC']#['Hydrophobicity and Charge'][0]['Patch_Neg_Charge_CDR']
                pnc_graph['data']['data01'][1][3] = nb_tnp_dictionary['PNC']#['Hydrophobicity and Charge'][0]['Patch_Neg_Charge_CDR']
                pnc_graph['axes'][0]['lines'][2]['color'] = flag2hex[nb_tnp_dictionary['Flags']['PNC']]

                with open(os.path.join(output, "PNC_D3_Template.json"),"w") as fo4:
                    json.dump(pnc_graph,fo4)

        return nb_tnp_dictionary
    
    else:
        print("TNP failed for sequence %s" %(heavy_name[:-2]))
        return {}


# def tnp_protocol_model_mode(model_path,h_scale,output,web,verbose):  #user supplies the directory where all the models sit

#     model_name = model_path.split('/')[-1][:-4]
#     full_model_root = "/".join(os.path.abspath(model_path).split('/')[0:-1])

#     p = AntibodyParser(QUIET=True)
#     p.set_numbering_scheme('imgt'); p.set_region_definition('imgt')

#     try:
#         s = p.get_antibody_structure(model_path[:-4],model_path)
#         # Additional argument for modified ABDB version
#         #s = p.get_antibody_structure(model_path[:-4],model_path,allowed_species=["human","mouse"])
        
#         fab = s[0]["H"]

#         tot = 0
#         cdr3_len = 0

#         for i, cdr in enumerate(fab.get_CDRs()):
#             for res in cdr.get_residues():
#                 tot += 1
#                 if i == 2: # 3rd round, cdr3
#                     cdr3_len += 1

#         s.save(full_model_root+"/Final_Models/"+model_name+".pdb")

#         #Calculate CDR3 compactness
#         cdr3_compactness_rho = compactness_calc(model_path, "imgt", verbose=verbose)

#         if cdr3_compactness_rho != None:
#             cdr3_compactness = cdr3_len / cdr3_compactness_rho 
#         else:
#             cdr3_compactness = np.nan()

#         #Calculate charge/hydrophobicity properties
#         hydrophob_and_charge_dict = hydrophob_and_charge_calc(h_scale, 7.4, model_path, "IG", "imgt", verbose=verbose)

#         nb_tnp_dictionary = {}
#         nb_tnp_dictionary['name'] = model_name
#         nb_tnp_dictionary['Total CDR Length'] = tot
#         nb_tnp_dictionary['CDR3 Length'] = cdr3_len
#         nb_tnp_dictionary['CDR3 Compactness'] = cdr3_compactness
#         nb_tnp_dictionary['PSH'] = hydrophob_and_charge_dict[0]['Patch_Hydrophob_CDR']
#         nb_tnp_dictionary['PPC'] = hydrophob_and_charge_dict[0]['Patch_Pos_Charge_CDR']
#         nb_tnp_dictionary['PNC'] = hydrophob_and_charge_dict[0]['Patch_Neg_Charge_CDR']

#         nb_tnp_dictionary['Flags'] = { "L"     : assign_flag("L", tot),
#                                 "L3"    : assign_flag("L3", cdr3_len),
#                                 "C"     : assign_flag("C", cdr3_compactness),
#                                 "PSH"   : assign_flag("PSH", hydrophob_and_charge_dict[0]['Patch_Hydrophob_CDR']),
#                                 "PPC"   : assign_flag("PPC", hydrophob_and_charge_dict[0]['Patch_Pos_Charge_CDR']),
#                                 "PNC"   : assign_flag("PNC", hydrophob_and_charge_dict[0]['Patch_Neg_Charge_CDR'])}

#         return nb_tnp_dictionary
    
#     except:
#         nb_tnp_dictionary = {}
#         return nb_tnp_dictionary

####################################################################################################
####################################################################################################
####################################################################################################

if __name__ == "__main__":

    # Set up argument parser
    parser = argparse.ArgumentParser(description="TNP Required Arguments")

    parser.add_argument('--hscale',dest='h_scale',default=0,help='Hydrophobicity Scale: 0 for Kyte and Doolittle, 1 for Whimley and White, 2 for Hessa et al, 3 for Eisenberg and McLachlan, 4 for Black and Mould. Defaults to Kyte and Doolittle.')
    parser.add_argument('--name',dest='name',default='Nb1',help='Sequence or dataset name. Defaulted to Nb1 for a single sequence.')
    parser.add_argument('--output',dest='output',help='The folder to which TNP should send all outputs',default='TNP_output',type=os.path.abspath)
    parser.add_argument('--web','-w',action='store_true',default=False, help="Flag that this is being running for the web front end. JSON files will be written.", dest="web")
    parser.add_argument('--verbose','-v',action='store_true',default=False, help="Turns on verbose output. Only for runs using 1 core.", dest="verbose")
    parser.add_argument('--ncores',dest='ncores',default=1,help='The number of cores TNP should use for this run.')

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--seq','-s',dest='sequence',help='Nanobody sequence for TNP analysis - in the form "[sequence]"')
    group.add_argument('--file','-f',dest='file',help='A file containing multiple nanobody sequences in FASTA format.', type=os.path.abspath)
    # group.add_argument('--models','-m',dest='model_folder',help='A folder containing nanobody models for processing through TNP', type=os.path.abspath)

    args = parser.parse_args()

    h_scale = int(args.h_scale)
    output = str(args.output)
    web = args.web
    verbose = args.verbose
    ncores = int(args.ncores)
    start = time.time()
    
    # Make output directory if it doesn't already exist
    if os.path.exists(output) is False:
        os.makedirs(output)
    os.chdir(output)
    # if os.path.exists(os.path.join(output, "Outputs")) is False:
    #     os.mkdir("Outputs")
    if os.path.exists(os.path.join(output, "Raw_Model_Outputs")) is False:
        os.mkdir("Raw_Model_Outputs")
    if os.path.exists(os.path.join(output, "Final_Models")) is False:
        os.mkdir("Final_Models")

    if h_scale == 0:
        print("The hydrophobicity scale is set to Kyte & Doolittle")
    elif h_scale == 1:
        print("The hydrophobicity scale is set to Whimley & White")
    elif h_scale == 2:
        print("The hydrophobicity scale is set to Hessa et al.")
    elif h_scale == 3:
        print("The hydrophobicity scale is set to Eisenberg & McLachlan")
    elif h_scale == 4:
        print("The hydrophobicity scale is set to Black & Mould")

    if args.name:
        name = str(args.name)

    sequences = {}
    # Single sequence input
    if args.sequence:
        seq = str(args.sequence)
        heavy_name,heavy_chain = (name+"_H",seq.upper())
        print("You have chosen the single sequence option.\nSequence name is: "+name+"\nSequence is: "+str(heavy_chain))
        print(linedivide)
        
        sequences[name] = {"heavy_name": heavy_name,
                           "heavy_chain": heavy_chain}

        results_dict = {name: main(heavy_name,heavy_chain,h_scale,output,web,verbose)}
        
        with open("TNP_Results_SingleSeqEntry_"+name+".json","w") as fo:
            json.dump(results_dict,fo)

    # Fasta file input
    elif args.file:
        results_dict = {}
        print("You have chosen to supply your sequences in a FASTA file.")
        
        file_dest = args.file
        try:
            for line in SeqIO.parse(file_dest,"fasta"):
                seq = str(line.seq)
                
                heavy_name,heavy_chain = (line.id+"_H",seq)
                
                sequences[line.id] = {"heavy_name": heavy_name,
                                      "heavy_chain": heavy_chain}
                                      
            print("The fasta file provided contains %d sequences." %(len(sequences)))
            print("TNP will use %d core(s)." %(ncores))
            print(linedivide)
        except:
            sys.exit("Error: please ensure you have supplied your sequences in FASTA format.")
            
        if ncores <= 1:
            for seqid in sequences:
                heavy_name = sequences[seqid]["heavy_name"]
                heavy_chain = sequences[seqid]["heavy_chain"]
                results_dict[seqid] = main(heavy_name,heavy_chain,h_scale,output,web,verbose)
        else:
            job_params = {}
            for seqid in sequences:
                job_params[seqid] = [sequences[seqid]["heavy_name"], sequences[seqid]["heavy_chain"], h_scale, output, web, verbose]
            pool = mp.Pool(ncores)
            j_list  = [ pool.apply_async( main, args = (blah) ) for blah in list(job_params.values()) ]
            mp_results = [ j.get() for j in j_list ]
            
            results_dict = {}
            for r in mp_results:
                if r:
                    results_dict[r['name']] = r
        
        with open("TNP_Results_Multientry.json","w") as fo:
                json.dump(results_dict,fo)

    # elif args.model_folder:
    #     results_dict = {}
    #     print("You are running TNP on a set of pre-computed models.")
    #     print("WARNING: Structures should not contain hydrogens - hydrogens are stripped when in sequence mode.")
    
    #     job_params = {}

    #     for pdb in glob.glob(args.model_folder+"/*pdb"):
    #         job_params[pdb] = [pdb,h_scale,output,web,verbose]

    #     subprocess.call(["mkdir",args.model_folder+"/Final_Models/"])
    #     subprocess.call(["mkdir",args.model_folder+"/tmp/"])

    #     pool = mp.Pool(ncores)
    #     j_list = [ pool.apply_async(tnp_protocol_model_mode, args = (blah) ) for blah in list(job_params.values())]
    #     mp_results = [ j.get() for j in j_list ]


    #     results_dict = {}
    #     for r in mp_results:
    #         if r:
    #             results_dict[r['name']] = r
    
    #     print("Job Complete!")

    #     with open("TNP_Results_Multientry.json","w") as fo:
    #         json.dump(results_dict,fo)

    elapsed = (time.time() - start)
    print(linedivide)
    print("TNP is Complete! It took %.2fs running on %d core(s).\n" %(elapsed, ncores))
        
    # Print results summary
    if args.sequence or args.file:
        for seqid in sequences:
            if seqid in results_dict and results_dict[seqid] != {}:
                print("\n")
                print("Summary Statistics for %s:\n" %(seqid))
                print("    Total IMGT CDR Length: %d (%s flag)" %(results_dict[seqid]['Total CDR Length'], results_dict[seqid]['Flags']['L'].upper()))
                print("    IMGT CDR3 Length: %d (%s flag)" %(results_dict[seqid]['CDR3 Length'], results_dict[seqid]['Flags']['L3'].upper()))
                print("    CDR Compactness: %f (%s flag)" %(results_dict[seqid]['CDR3 Compactness'], results_dict[seqid]['Flags']['C'].upper()))
                print("    Patch CDR Surface Hydrophobicity score is: %f (%s flag)" %(results_dict[seqid]['PSH'], results_dict[seqid]['Flags']['PSH'].upper()))
                print("    Patch CDR Positive Charge score is: %f (%s flag)" %(results_dict[seqid]['PPC'], results_dict[seqid]['Flags']['PPC'].upper()))
                print("    Patch CDR Negative Charge score is: %f (%s flag)" %(results_dict[seqid]['PNC'], results_dict[seqid]['Flags']['PNC'].upper()))
            else:
                print("TNP crashed on sequence %s\n" %(seqid))
        
        print(linedivide)

