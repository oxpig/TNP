#!/data/localhost/gordon/miniconda3/envs/nanob/bin/python

####################################################################################################
####                          The Therapeutic Nanobody Profiler (TNP)                           ####
####################################################################################################

#AUTHORS: Gemma Gordon (1), Charlotte M Deane (1)
#
#(1) Department of Statistics (Oxford Protein Informatics Group), University of Oxford, UK

####################################################################################################
# REQUIRED MODULES
from theraprofnano.CDR_Profiler.CDR_Assigner import main as region_and_aa_dicts
from theraprofnano.CDR_Profiler.CDR3_Conf_Assigner import main_compactness as compactness_calc
from theraprofnano.Hydrophobicity_and_Charge_Profiler.Hydrophobicity_and_Charge_Assigner import CreateAnnotation as hydrophob_and_charge_calc
from theraprofnano.Plotters.CDRLen_D3_Template import cdr_graph
from theraprofnano.Plotters.CDR3Len_D3_Template import cdr3_len_graph
from theraprofnano.Plotters.CDR3Conf_D3_Template import cdr3_conf_graph
from theraprofnano.Plotters.PSH_D3_Template import psh_graph
from theraprofnano.Plotters.PPC_D3_Template import ppc_graph
from theraprofnano.Plotters.PNC_D3_Template import pnc_graph
import numpy as np
from ABDB.AbPDB import AntibodyParser
from Bio import SeqIO
import pickle as pickle
import subprocess,time,re,argparse,json,os,sys,shutil
import multiprocessing as mp
import os,glob
import anarci
from anarci import anarci, run_anarci

####################################################################################################

columns = 100
linedivide = "\n\n" + ("-"*columns) + "\n\n"

header = linedivide + """

---------------------------------------------------------------------------------------------------------\n
---------------------------------------------------------------------------------------------------------\n
                \/                       _____ _   _ ____                   \/
                ⊂'l                      |_   _| \ | |  _ \                 ⊂'l     
                ll                        | | |  \| | |_) |                 ll     
                llama~                    | | | |\  |  __/                  llama~ 
                || ||                     |_| |_| \_|_|                     || || 
                '' ''                                                       '' ''
---------------------------------------------------------------------------------------------------------\n
---------------------------------------------------------------------------------------------------------\n

\nTHE THERAPEUTIC NANOBODY PROFILER\n

Gemma Gordon, 2025\n

Software developed in the Oxford Protein Informatics Group, Department of Statistics, University of Oxford\n

Example usage:\n

TNP -s QVKLQESGAELARPGASVKLSCKASGYTFTNYWMQWVKQRPGQGLDWIGAIYPGDGNTRYTHKFKGKATLTADKSSSTAYMQLSSLASEDSGVYYCARGEGNYAWFAYWGQGTTVTVSS --output TNP_example_output
""" + linedivide


####################################################################################################
# UPDATE FLAG VALUES HERE    
# Function to assign a flag colour based on the value of a TNP metric
def assign_flag(metric, value):
    
    # Total CDR Length (L)
    if metric == "L":
        if   value <  20 or  value >  39:
            return "red"
        elif value >= 20 and value <= 24:
            return "amber"
        elif value >= 37 and value <= 39:
            return "amber"
        else:
            return "green"
        
    # CDR3 Length (L3)
    elif metric == "L3":
        if   value <  5 or  value >  23:
            return "red"
        elif value >= 5 and value <= 8:
            return "amber"
        elif value >= 21 and value <= 23:
            return "amber"
        else:
            return "green"
    
    # Total CDR3 compactness (C)
    elif metric == "C":
        if   value <  0.56 or  value >  1.61:
            return "red"
        elif value >= 0.56 and value <= 0.81:
            return "amber"
        elif value >= 1.57 and value <= 1.61:
            return "amber"
        else:
            return "green"
            
    # Patches of surface hydrophobicity (PSH)
    elif metric == "PSH":
        if   value <  73.40 or  value >  155.47:
            return "red"
        elif value >= 73.40 and value <= 79.59:
            return "amber"
        elif value >= 126.83 and value <= 155.47:
            return "amber"
        else:
            return "green"

    # Patches of positive charge (PPC)
    elif metric == "PPC":
        if   value > 1.18:
            return "red"
        elif value >= 0.39 and value <= 1.18:
            return "amber"
        else:
            return "green"
            
    # Patches of negative charge (PNC)
    elif metric == "PNC":
        if   value > 1.88:
            return "red"
        elif value >= 1.47 and value <= 1.88:
            return "amber"
        else:
            return "green"
            
            
####################################################################################################
# Stuff to remove hydrogens from NanoBodyBuilder2 output models 
# NOTE - from TAP - [23 Jan 2023, Broncio]: ImmuneBuilder add hydrogens by default for openmm relaxation
import re
from Bio.PDB import PDBParser, PDBIO, Select

_hydrogen = re.compile("[123 ]*H.*")

class RemoveHydrogen(Select):
    def accept_atom(self, atom):
        """Verify if atoms are not Hydrogen."""
        # atoms - get rid of hydrogens
        name = atom.get_id()
        return 0 if _hydrogen.match(name) else 1

def pdb_remove_hydrogens(input_pdb):
    try:
        pdb = PDBParser().get_structure("antibody", input_pdb)
        io = PDBIO()
        io.set_structure(pdb)

        output_model = f'{input_pdb[:-4]}.pdb'
        io.save(output_model, RemoveHydrogen())

    except Exception as e:
        print(e)

####################################################################################################

def get_tetrad_residues(sequence):
    """
    Returns tetrad motif/hallmark residues on the nanobody FR2 region - sequence input mode only
    
    """

    # Get tetrad positions and residue from numbering sequence
    tetrad_residues = []
    tetrad_positions = [42,49,50,52] # IMGT positions
    numbering =  run_anarci(sequence, scheme='IMGT', allowed_species=None)[1][0][0][0]
    for n in numbering:
        if n[0][0] in tetrad_positions:
            tetrad_residues.append((n[0][0],n[1]))
    
    tetrad_motif = ''.join(t[1] for t in tetrad_residues)

    return tetrad_motif


####################################################################################################


# Main function that runs TNP on a sequence
def main(heavy_name, heavy_sequence, h_scale, output, web, verbose=False):

    if True:
        CDR_data_loc = os.path.join(output, "Outputs")
        Model_data_loc = os.path.join(output, "Final_Models")
        status = "Good"
        abbrev_name = heavy_name[:-2]
        print("TNP is running on sequence %s" %(abbrev_name))

        logfile = os.path.join(output, abbrev_name+"_TNP.log")
        with open(logfile,"w") as fo:
        
            fo.write("The TNP job initialised successfully for "+abbrev_name+".\nIt will calculate total CDR length, CDR3 length, CDR3 compactness, and patches of surface hydrophobicity and charge.\n\n--------------------------------------------------------------\n\n")

            if verbose: print("\nAnalysing CDR loops...\n\n")

            try:
                heavy_cdr_dict, heavy_len_dict = region_and_aa_dicts(heavy_name,heavy_sequence,"H",output,verbose=verbose)
                fo.write("TNP managed to number the sequence with ANARCI\n")
            except:
                print("TNP could not number the sequence %s with ANARCI" %abbrev_name)
                fo.write("TNP failed to number the sequence with ANARCI\n")
                return

            total_imgt_cdr_length = 0
            heavy_loops = ['cdrh1','cdrh2','cdrh3']

            # Calculate total CDR loops length
            for loop in heavy_loops:
                total_imgt_cdr_length += heavy_len_dict['imgt'][loop]
            
            # Calculate CDR3 loop length
            imgt_cdr3_length = heavy_len_dict['imgt']['cdrh3']

            if verbose: 
                print(linedivide + "Calling NanoBodyBuilder2 (ImmuneBuilder model for nanobodies) to model your nanobody\n\n") # NEW

            try:
                os.mkdir(abbrev_name)

                cmd = ["NanoBodyBuilder2",
                       "--heavy_sequence", heavy_sequence,
                       "--output", os.path.join(abbrev_name, abbrev_name + ".pdb"),
                       "--n_threads", "1"]
                if verbose:
                    cmd.append("--verbose")
                    
                subprocess.run(cmd, check=True)

                fo.write("NanoBodyBuilder2 (ImmuneBuilder) was able to generate a model for this sequence\n")

                try:
                    input_pdb = os.path.join(abbrev_name, abbrev_name)+".pdb"
                    pdb_remove_hydrogens(input_pdb)
                    print("Removed all Hydrogens from NanoBodyBuilder2 model")
                    
                except Exception as e:
                        print(e)

            except Exception as e: 
                print("ERROR: NanoBodyBuilder2 (ImmuneBuilder) failed to generate a model for your nanobody")
                fo.write("NanoBodyBuilder2 (ImmuneBuilder) was unable to generate a model for your nanobody\n")
                print(e)
                return

            try:
                # Generate modelling_details.jsonp file (Now a separate step from ImmuneBuilder)
                # import sys
                # sys.path.append("../scripts/")
                from scripts.process_pdb import get_modelling_details
                modelling_details = get_modelling_details(os.path.join(abbrev_name, abbrev_name)+".pdb",type='nanobody',save=True)
                fo.write("Saved modelling_details.jsonp for NanoBodyBuilder2 (ImmuneBuilder) model\n")

            except Exception as e:
                print("ERROR: Failed to process output PDB. " + str(e))

            if os.path.exists(os.path.join("Raw_Model_Outputs", abbrev_name)):
                shutil.rmtree(os.path.join("Raw_Model_Outputs", abbrev_name))
            subprocess.call(["mv",abbrev_name,"Raw_Model_Outputs/"+str(heavy_name[:-2])])
            subprocess.call(["cp","Raw_Model_Outputs/"+str(heavy_name[:-2])+"/"+abbrev_name+".pdb","Final_Models/"+str(heavy_name[:-2])+"_NanoBodyBuilder2_Model.pdb"])
            subprocess.call(["cp","Raw_Model_Outputs/"+str(heavy_name[:-2])+"/modelling_details.jsonp","Final_Models/"+str(heavy_name[:-2])+"_NanoBodyBuilder2_Model_Details.json"])
            subprocess.call(["cp","Raw_Model_Outputs/"+str(heavy_name[:-2])+"/sequence_liabilities.csv","Final_Models/"+str(heavy_name[:-2])+"_NanoBodyBuilder2_Sequence_Liabilities.json"])

            if verbose: 
                print(linedivide + "NanoBodyBuilder2 (ImmuneBuilder) successfully modelled your nanobody.\n\n")

            if verbose: 
                print(linedivide + "Calculating CDR3 compactness (a descriptor of conformation) for your nanobody.\n\n")

            cdr3_compactness_rho = compactness_calc(os.path.join(Model_data_loc, abbrev_name+"_NanoBodyBuilder2_Model.pdb"), "imgt", verbose=verbose)
            # in case calculation failed, e.g. anchor residues missing in structure
            if cdr3_compactness_rho != None:
                cdr3_compactness = cdr3_compactness_rho / imgt_cdr3_length
                fo.write("TNP was able to calculate a CDR3 compactness score for your model structure.\n")
                if verbose: 
                    print(linedivide + "TNP was able to calculate a CDR3 compactness score for your model structure.\n\n")
            else:
                cdr3_compactness = np.nan()
                fo.write("TNP was not able to calculate a CDR3 compactness score for your model structure.\n")
                if verbose: 
                    print(linedivide + "TNP was not able to calculate a CDR3 compactness score for your model structure.\n\n")


            if verbose:
                print(linedivide + "Getting nanobody hallmark residues (nanobody tetrad) from your sequence...\n\n")
            
            try:
                tetrad_motif = get_tetrad_residues(heavy_sequence)
                fo.write("Nanobody tetrad motif is: " + tetrad_motif +" (IMGT positions 42, 49, 50, 52)\n")
            except:
                tetrad_motif = None
                fo.write("Could not get nanobody hallmark residues (nanobody tetrad) from your sequence.\n")
                if verbose:
                    print(linedivide + "Could not get nanobody hallmark residues (nanobody tetrad) from your sequence...\n\n")
    

            if verbose:
                print(linedivide + "Finally, calculating surface hydrophobicity and charge properties for your nanobody at pH 7.4 (with salt-bridge correction)...\n\n")

            hydrophob_and_charge_dict = hydrophob_and_charge_calc(h_scale, 7.4, os.path.join(Model_data_loc, abbrev_name+"_NanoBodyBuilder2_Model.pdb"), "IG", "imgt", verbose=verbose)

            fo.write("TNP was able to calculate PSH, PPC and PNC scores for your model structure.\n")


            ###############################################################################################################

            nb_tnp_dictionary = {}
            nb_tnp_dictionary['name'] = abbrev_name
            nb_tnp_dictionary['Total CDR Length'] = total_imgt_cdr_length
            nb_tnp_dictionary['CDR3 Length'] = imgt_cdr3_length
            nb_tnp_dictionary['CDR3 Compactness'] = cdr3_compactness
            nb_tnp_dictionary['PSH'] = hydrophob_and_charge_dict[h_scale]['Patch_Hydrophob_CDR']
            nb_tnp_dictionary['PPC'] = hydrophob_and_charge_dict[h_scale]['Patch_Pos_Charge_CDR']
            nb_tnp_dictionary['PNC'] = hydrophob_and_charge_dict[h_scale]['Patch_Neg_Charge_CDR']
            
            nb_tnp_dictionary['Flags'] = { "L"     : assign_flag("L", total_imgt_cdr_length),
                                           "L3"    : assign_flag("L3", imgt_cdr3_length),
                                           "C"     : assign_flag("C", cdr3_compactness),
                                           "PSH"   : assign_flag("PSH", hydrophob_and_charge_dict[h_scale]['Patch_Hydrophob_CDR']),
                                           "PPC"   : assign_flag("PPC", hydrophob_and_charge_dict[h_scale]['Patch_Pos_Charge_CDR']),
                                           "PNC"   : assign_flag("PNC", hydrophob_and_charge_dict[h_scale]['Patch_Neg_Charge_CDR'])}
                                           
            fo.write("\n\nSummary Statistics for %s:\n" %(abbrev_name))
            fo.write("    Total IMGT CDR Length: %d (%s flag)\n" %(nb_tnp_dictionary['Total CDR Length'], nb_tnp_dictionary['Flags']['L'].upper()))
            fo.write("    IMGT CDR3 Length: %d (%s flag)\n" %(nb_tnp_dictionary['CDR3 Length'], nb_tnp_dictionary['Flags']['L3'].upper()))
            fo.write("    IMGT CDR3 compactness: %f (%s flag)\n" %(nb_tnp_dictionary['CDR3 Compactness'], nb_tnp_dictionary['Flags']['C'].upper()))
            fo.write("    Patch CDR Surface Hydrophobicity score is: %f (%s flag)\n" %(nb_tnp_dictionary['PSH'], nb_tnp_dictionary['Flags']['PSH'].upper()))
            fo.write("    Patch CDR Positive Charge score is: %f (%s flag)\n" %(nb_tnp_dictionary['PPC'], nb_tnp_dictionary['Flags']['PPC'].upper()))
            fo.write("    Patch CDR Negative Charge score is: %f (%s flag)\n" %(nb_tnp_dictionary['PNC'], nb_tnp_dictionary['Flags']['PNC'].upper()))

            # Populate the output graphs!
            # Only if being run for the web server
            if web:
                from theraprofnano.Plotters.CDRLen_D3_Template import cdr_graph
                from theraprofnano.Plotters.CDR3Len_D3_Template import cdr3_len_graph
                from theraprofnano.Plotters.CDR3Conf_D3_Template import cdr3_conf_graph
                from theraprofnano.Plotters.PSH_D3_Template import psh_graph
                from theraprofnano.Plotters.PPC_D3_Template import ppc_graph
                from theraprofnano.Plotters.PNC_D3_Template import pnc_graph

                flag2hex = { "red": "#FF0000", "amber": "#FFA500", "green": "#5CBE67" }

                #CDR LENGTH GRAPH
                cdr_graph['data']['data01'][0][5] = nb_tnp_dictionary['Total CDR Length']        # 5 for upper and lower bound, 3 for upper only
                cdr_graph['data']['data01'][1][5] = nb_tnp_dictionary['Total CDR Length']
                cdr_graph['axes'][0]['lines'][4]['color'] = flag2hex[nb_tnp_dictionary['Flags']['L']]

                with open(os.path.join(output, "CDRLen_D3_Template.json"),"w") as fo4:
                    json.dump(cdr_graph,fo4)

                #CDR3 LENGTH GRAPH
                cdr3_len_graph['data']['data01'][0][5] = nb_tnp_dictionary['CDR3 Length']        
                cdr3_len_graph['data']['data01'][1][5] = nb_tnp_dictionary['CDR3 Length']
                cdr3_len_graph['axes'][0]['lines'][4]['color'] = flag2hex[nb_tnp_dictionary['Flags']['L3']]

                with open(os.path.join(output, "CDR3Len_D3_Template.json"),"w") as fo4:
                    json.dump(cdr3_len_graph,fo4)
                
                #CDR3 COMPACTNESS GRAPH
                cdr3_conf_graph['data']['data01'][0][5] = nb_tnp_dictionary['CDR3 Compactness']       
                cdr3_conf_graph['data']['data01'][1][5] = nb_tnp_dictionary['CDR3 Compactness']
                cdr3_conf_graph['axes'][0]['lines'][4]['color'] = flag2hex[nb_tnp_dictionary['Flags']['C']]

                with open(os.path.join(output, "CDR3Conf_D3_Template.json"),"w") as fo4:
                    json.dump(cdr3_conf_graph,fo4)

                #PSH GRAPH
                psh_graph['data']['data01'][0][5] = nb_tnp_dictionary['PSH']#['Hydrophobicity and Charge'][0]['Patch_Hydrophob_CDR']
                psh_graph['data']['data01'][1][5] = nb_tnp_dictionary['PSH']#['Hydrophobicity and Charge'][0]['Patch_Hydrophob_CDR']
                psh_graph['axes'][0]['lines'][4]['color'] = flag2hex[nb_tnp_dictionary['Flags']['PSH']]       

                with open(os.path.join(output, "PSH_D3_Template.json"),"w") as fo4:
                    json.dump(psh_graph,fo4)

                #PPC GRAPH
                ppc_graph['data']['data01'][0][3] = nb_tnp_dictionary['PPC']#['Hydrophobicity and Charge'][0]['Patch_Pos_Charge_CDR']
                ppc_graph['data']['data01'][1][3] = nb_tnp_dictionary['PPC']#['Hydrophobicity and Charge'][0]['Patch_Pos_Charge_CDR']
                ppc_graph['axes'][0]['lines'][2]['color'] = flag2hex[nb_tnp_dictionary['Flags']['PPC']]

                with open(os.path.join(output, "PPC_D3_Template.json"),"w") as fo4:
                    json.dump(ppc_graph,fo4)

                #PNC GRAPH
                pnc_graph['data']['data01'][0][3] = nb_tnp_dictionary['PNC']#['Hydrophobicity and Charge'][0]['Patch_Neg_Charge_CDR']
                pnc_graph['data']['data01'][1][3] = nb_tnp_dictionary['PNC']#['Hydrophobicity and Charge'][0]['Patch_Neg_Charge_CDR']
                pnc_graph['axes'][0]['lines'][2]['color'] = flag2hex[nb_tnp_dictionary['Flags']['PNC']]

                with open(os.path.join(output, "PNC_D3_Template.json"),"w") as fo4:
                    json.dump(pnc_graph,fo4)

        return nb_tnp_dictionary
    
    else:
        print("TNP failed for sequence %s" %(heavy_name[:-2]))
        return {}


def tnp_protocol_model_mode(model_path,h_scale,output,web,verbose):  #user supplies the directory where all the models sit

    model_name = model_path.split('/')[-1][:-4]
    full_model_root = "/".join(os.path.abspath(model_path).split('/')[0:-1])

    p = AntibodyParser(QUIET=True)
    p.set_numbering_scheme('imgt'); p.set_region_definition('imgt')

    try:
        s = p.get_antibody_structure(model_path[:-4],model_path)
        # Additional argument for modified ABDB version
        #s = p.get_antibody_structure(model_path[:-4],model_path,allowed_species=["human","mouse"])
        
        fab = s[0]["H"]

        tot = 0
        cdr3_len = 0

        for i, cdr in enumerate(fab.get_CDRs()):
            for res in cdr.get_residues():
                tot += 1
                if i == 2: # 3rd round, cdr3
                    cdr3_len += 1

        s.save(full_model_root+"/Final_Models/"+model_name+".pdb")

        #Calculate CDR3 compactness
        cdr3_compactness_rho = compactness_calc(model_path, "imgt", verbose=verbose)

        if cdr3_compactness_rho != None:
            cdr3_compactness = cdr3_compactness_rho / cdr3_len
        else:
            cdr3_compactness = np.nan()

        #Calculate charge/hydrophobicity properties
        hydrophob_and_charge_dict = hydrophob_and_charge_calc(h_scale, 7.4, model_path, "IG", "imgt", verbose=verbose)

        nb_tnp_dictionary = {}
        nb_tnp_dictionary['name'] = model_name
        nb_tnp_dictionary['Total CDR Length'] = tot
        nb_tnp_dictionary['CDR3 Length'] = cdr3_len
        nb_tnp_dictionary['CDR3 Compactness'] = cdr3_compactness
        nb_tnp_dictionary['PSH'] = hydrophob_and_charge_dict[0]['Patch_Hydrophob_CDR']
        nb_tnp_dictionary['PPC'] = hydrophob_and_charge_dict[0]['Patch_Pos_Charge_CDR']
        nb_tnp_dictionary['PNC'] = hydrophob_and_charge_dict[0]['Patch_Neg_Charge_CDR']

        nb_tnp_dictionary['Flags'] = { "L"     : assign_flag("L", tot),
                                "L3"    : assign_flag("L3", cdr3_len),
                                "C"     : assign_flag("C", cdr3_compactness),
                                "PSH"   : assign_flag("PSH", hydrophob_and_charge_dict[0]['Patch_Hydrophob_CDR']),
                                "PPC"   : assign_flag("PPC", hydrophob_and_charge_dict[0]['Patch_Pos_Charge_CDR']),
                                "PNC"   : assign_flag("PNC", hydrophob_and_charge_dict[0]['Patch_Neg_Charge_CDR'])}

        return nb_tnp_dictionary
    
    except:
        nb_tnp_dictionary = {}
        return nb_tnp_dictionary

####################################################################################################
####################################################################################################
####################################################################################################

if __name__ == "__main__":

    # Set up argument parser
    parser = argparse.ArgumentParser(description="TNP Required Arguments")

    parser.add_argument('--hscale',dest='h_scale',default=0,help='Hydrophobicity Scale: 0 for Kyte and Doolittle, 1 for Whimley and White, 2 for Hessa et al, 3 for Eisenberg and McLachlan, 4 for Black and Mould. Defaults to Kyte and Doolittle.')
    parser.add_argument('--name',dest='name',default='Nb1',help='Sequence or dataset name. Defaulted to Nb1 for a single sequence.')
    parser.add_argument('--output',dest='output',help='The folder to which TNP should send all outputs',default='TNP_output',type=os.path.abspath)
    parser.add_argument('--web','-w',action='store_true',default=False, help="Flag that this is being running for the web front end. JSON files will be written.", dest="web")
    parser.add_argument('--verbose','-v',action='store_true',default=False, help="Turns on verbose output. Only for runs using 1 core.", dest="verbose")
    parser.add_argument('--ncores',dest='ncores',default=1,help='The number of cores TNP should use for this run.')

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--seq','-s',dest='sequence',help='Nanobody sequence for TNP analysis - in the form "[sequence]"')
    group.add_argument('--file','-f',dest='file',help='A file containing multiple nanobody sequences in FASTA format.', type=os.path.abspath)
    group.add_argument('--models','-m',dest='model_folder',help='A folder containing nanobody models for processing through TNP', type=os.path.abspath)

    args = parser.parse_args()

    h_scale = int(args.h_scale)
    output = str(args.output)
    web = args.web
    verbose = args.verbose
    ncores = int(args.ncores)
    start = time.time()
    
    # Make output directory if it doesn't already exist
    if os.path.exists(output) is False:
        os.makedirs(output)
    os.chdir(output)
    # if os.path.exists(os.path.join(output, "Outputs")) is False:
    #     os.mkdir("Outputs")
    if os.path.exists(os.path.join(output, "Raw_Model_Outputs")) is False:
        os.mkdir("Raw_Model_Outputs")
    if os.path.exists(os.path.join(output, "Final_Models")) is False:
        os.mkdir("Final_Models")

    if h_scale == 0:
        print("The hydrophobicity scale is set to Kyte & Doolittle")
    elif h_scale == 1:
        print("The hydrophobicity scale is set to Whimley & White")
    elif h_scale == 2:
        print("The hydrophobicity scale is set to Hessa et al.")
    elif h_scale == 3:
        print("The hydrophobicity scale is set to Eisenberg & McLachlan")
    elif h_scale == 4:
        print("The hydrophobicity scale is set to Black & Mould")

    if args.name:
        name = str(args.name)

    sequences = {}
    # Single sequence input
    if args.sequence:
        seq = str(args.sequence)
        heavy_name,heavy_chain = (name+"_H",seq.upper())
        print("You have chosen the single sequence option.\nSequence name is: "+name+"\nSequence is: "+str(heavy_chain))
        print(linedivide)
        
        sequences[name] = {"heavy_name": heavy_name,
                           "heavy_chain": heavy_chain}

        results_dict = {name: main(heavy_name,heavy_chain,h_scale,output,web,verbose)}
        
        with open("TNP_Results_SingleSeqEntry_"+name+".json","w") as fo:
            json.dump(results_dict,fo)

    # Fasta file input
    elif args.file:
        results_dict = {}
        print("You have chosen to supply your sequences in a FASTA file.")
        
        file_dest = args.file
        try:
            for line in SeqIO.parse(file_dest,"fasta"):
                seq = str(line.seq)
                
                heavy_name,heavy_chain = (line.id+"_H",seq)
                
                sequences[line.id] = {"heavy_name": heavy_name,
                                      "heavy_chain": heavy_chain}
                                      
            print("The fasta file provided contains %d sequences." %(len(sequences)))
            print("TNP will use %d core(s)." %(ncores))
            print(linedivide)
        except:
            sys.exit("Error: please ensure you have supplied your sequences in FASTA format.")
            
        if ncores <= 1:
            for seqid in sequences:
                heavy_name = sequences[seqid]["heavy_name"]
                heavy_chain = sequences[seqid]["heavy_chain"]
                results_dict[seqid] = main(heavy_name,heavy_chain,h_scale,output,web,verbose)
        else:
            job_params = {}
            for seqid in sequences:
                job_params[seqid] = [sequences[seqid]["heavy_name"], sequences[seqid]["heavy_chain"], h_scale, output, web, verbose]
            pool = mp.Pool(ncores)
            j_list  = [ pool.apply_async( main, args = (blah) ) for blah in list(job_params.values()) ]
            mp_results = [ j.get() for j in j_list ]
            
            results_dict = {}
            for r in mp_results:
                if r:
                    results_dict[r['name']] = r
        
        with open("TNP_Results_Multientry.json","w") as fo:
                json.dump(results_dict,fo)

    elif args.model_folder:
        results_dict = {}
        print("You are running TNP on a set of pre-computed models.")
    
        job_params = {}

        for pdb in glob.glob(args.model_folder+"/*pdb"):
            job_params[pdb] = [pdb,h_scale,output,web,verbose]

        subprocess.call(["mkdir",args.model_folder+"/Final_Models/"])
        subprocess.call(["mkdir",args.model_folder+"/tmp/"])

        pool = mp.Pool(ncores)
        j_list = [ pool.apply_async(tnp_protocol_model_mode, args = (blah) ) for blah in list(job_params.values())]
        mp_results = [ j.get() for j in j_list ]


        results_dict = {}
        for r in mp_results:
            if r:
                results_dict[r['name']] = r
    
        print("Job Complete!")

        with open("TNP_Results_Multientry.json","w") as fo:
            json.dump(results_dict,fo)

    elapsed = (time.time() - start)
    print(linedivide)
    print("TNP is Complete! It took %.2fs running on %d core(s).\n" %(elapsed, ncores))
        
    # Print results summary
    if args.sequence or args.file:
        for seqid in sequences:
            if seqid in results_dict and results_dict[seqid] != {}:
                print("\n")
                print("Summary Statistics for %s:\n" %(seqid))
                print("    Total IMGT CDR Length: %d (%s flag)" %(results_dict[seqid]['Total CDR Length'], results_dict[seqid]['Flags']['L'].upper()))
                print("    IMGT CDR3 Length: %d (%s flag)" %(results_dict[seqid]['CDR3 Length'], results_dict[seqid]['Flags']['L3'].upper()))
                print("    CDR Compactness: %f (%s flag)" %(results_dict[seqid]['CDR3 Compactness'], results_dict[seqid]['Flags']['C'].upper()))
                print("    Patch CDR Surface Hydrophobicity score is: %f (%s flag)" %(results_dict[seqid]['PSH'], results_dict[seqid]['Flags']['PSH'].upper()))
                print("    Patch CDR Positive Charge score is: %f (%s flag)" %(results_dict[seqid]['PPC'], results_dict[seqid]['Flags']['PPC'].upper()))
                print("    Patch CDR Negative Charge score is: %f (%s flag)" %(results_dict[seqid]['PNC'], results_dict[seqid]['Flags']['PNC'].upper()))
            else:
                print("TNP crashed on sequence %s\n" %(seqid))
        
        print(linedivide)

